# Tugas 2

a.	Mengimplementasi checklist tugas:
    Pertama-tama yang kita harus lakukan adalah menginisiasi proyek django. Ini dilakukan dengan membuat direktori baru yang bernama sports-gear. Lalu kita buka command prompt di direktori tersebut dan menjalankan command “python -m venv env” untuk membuat virtual environment dan “env\Scripts\activate” untuk mengaktifkan virtual environment tersebut. 
    Tahap selanjutnya adalah membuat requirements.txt pada direktori umum yang sama. Saya sendiri menggunakan requirements yang ada pada tutorial 0. Setelah itu, kita harus install requirements tersebut dengan “pip install -r requirements.txt” di cmd. Lalu saya membuat proyek Django dengan nama sports_gear yang nantinya akan berada pada direktori sports-gear.
    Langkah selanjutnya kita menambahkan file .env dan .env.prod di direktori umum. Konfigurasi .env dan .env.prod sesuai dengan yang ada pada tutorial 0. Setelah sudah mengonfigurasi kedua hal tersebut, kita harus mengonfigurasi settings.py. Settings.py ini sudah ada pada direktori sports_gear jadi kita tidak perlu membuatnya lagi. Di file tersebut, kita harus mengganti dan menambahkan beberapa hal seperti yang sudah diajarkan pada tutorial 0 agar konfigurasi sesuai. Setelah kita selesai mengonfigurasi semuanya, kita dapat memigrasikan database dengan menginput command ‘python manage.py migrate” di cmd.
    Tahap berikutnya adalah membuat file .gitignore di direktori sports-gear. Saya mengisi file tersebut sesuai dengan apa yang sudah diajari pada tutorial 0. Dan tahap terakhir untuk menyelesaikan checklist pertama adalah mem-push proyek dari direktori lokal ke repo github. Sebelumnya, kita perlu membuat repo github dengan nama Sports-Gear dan pastikan visibility nya public. Setelah itu kita koneksikan direktori lokal kita ke repo tersebut dengan menjalankan command 1) git init; 2) git remote add origin https://github.com/HaikalMuzaki/Sports-Gear.git; 3) git branch -M master; 4) git add .; 5) git commit -m “inisiasi django”; 6) git push origin master.
    Checklist selanjutnya adalah membuat aplikasi main. Sebelumnya, pastikan virtual environment sudah aktif pada cmd direktori umum. Jika sudah dicek, kita langsung dapat membuat aplikasi main dengan menjalankan command “python manage.py startapp main” di cmd. Lalu, buka settings.py yang ada dalam direktori sports_gear dan tambahkan ‘main’ pada list INSTALLED_APPS.
    Setelah aplikasi main berhasil dibuat, tahap berikutnya adalah menghubungkannya dengan proyek utama melalui routing. Pertama, saya membuka urls.py yang ada pada direktori sports_gear (project utama). Di dalamnya, saya menambahkan kode path('', include('main.urls')) agar project bisa diarahkan ke aplikasi main. Karena urls.py pada aplikasi main belum ada, saya membuat file tersebut secara manual dan menambahkan routing untuk fungsi show_main.
    Selanjutnya, saya membuat model dengan nama Product pada file models.py di aplikasi main. Model ini memiliki atribut yang diwajibkan oleh checklist. Lebih dari itu, saya juga mengganti isi tuples yang berhubungan sama aplikasi yang dibuat dan juga mengganti beberapa fungsi yang berada di bawah atribut. Setelah model selesai dibuat, saya menjalankan perintah python manage.py makemigrations dan python manage.py migrate untuk menyimpan perubahan model ke dalam database.
    Kemudian, saya membuat fungsi show_main di dalam views.py yang mengembalikan template HTML main.html. template main.html ini kita harus buat sebelumnya. Buatlah folder template di direktori main dan di dalamnya buatlah file main.html yang berisi template yang ingin dibuat. Untuk tugas ini, saya hanya memodifikasi template yang sudah pernah diberi saat tutorial 1. Kembali lagi ke fungsi show_main, fungsi ini berisi context yang menampilkan nama aplikasi (Sports Gear), serta data diri saya yaitu Haikal Muzaki dan kelas PBP B. Setelah fungsi dibuat, saya menambahkan routing di urls.py aplikasi main dengan path('', show_main, name='show_main').
    Sebelum proyek diluncurkan, kita perlu melengkapi rute URL di level proyek. Caranya adalah dengan membuka urls.py yang ada pada direktori proyek sports_gear (bukan yang ada di aplikasi main), lalu mengimpor fungsi include dari django.urls “from django.urls import path, include”. Kemudia kita harus menambahkan konfigurasi “path('', include('main.urls')),” ke list urlpatterns.
    Sekarang proyek sudah siap untuk diluncurkan. Hal tersebut dapat dilakukan dengan menginput “python manage.py runserver” di cmd. Lalu bukalah  http://localhost:8000/ untuk melihat hasil kerja kamu.
    Terakhir adalah melakukan push ke github dan pws. Karena tadi kita sudah membuat repo di github, maka kita hanya perlu menginput ini di cmd: 1) git add .; 2) git commit -m “Assignment almost finish...”; 3) git push origin master. Untuk deployment ke PWS, kita harus mengingat kembali yang sudah diajarkan pada tutorial 0.
    Untuk mendeploy di PWS, kita harus menambahkan proyek tersebut di PWS. Pertama, akseslah halaman PWS, lalu klik create new project. Lengkapi nama projek (sportsgear) dan klik create new project yang ada dibawahnya (bukan yang ada di sidebar). Nanti web akan menampilkan kredensial dan itu perlu kalian catat. Setelah itu kita klik proyek kita yang ada pada sidebar dan kliklah menu environs. Gantilah variabel yang ada dengan meng-klik raw editor dan mengganti kode dengan kode .env.prod yang tadi sudah dibuat. Pada settings.py, tambahkan link deployment PWS pada allowed host. Link deployment PWS memiliki format <username-sso>-<nama proyek>.pbp.cs.ui.ac.id. Apabila pada username SSO kamu terdapat karakter titik (.), gantilah karakter tersebut menjadi hyphen (-). Setelah itu, jalankan input yang ada pada informasi project command pada halaman PWS di cmd direktori umum. Jalankan ketiga command line jika baru pertama kali push, jika sudah pernah meng-push sebelumnya, cukup menjalankan perintah “git push pws master”. Setelah itu, harusnya muncul window yang meminta kredensial proyek mu yang tadi. Lengkapilah kredensial tersebut, dan proyek mu berhasil di-deploy ke PWS. 

b.	.

c.	File settings.py memiliki peran penting sebagai pusat konfigurasi proyek Django. Di dalamnya terdapat berbagai pengaturan seperti daftar aplikasi yang digunakan (INSTALLED_APPS), pengaturan middleware, konfigurasi database, manajemen file statis, hingga konfigurasi keamanan seperti SECRET_KEY dan DEBUG. Setiap kali kita menambahkan aplikasi baru (misalnya main), kita perlu mendaftarkannya di INSTALLED_APPS pada settings.py agar Django mengenali aplikasi tersebut. Dengan kata lain, settings.py adalah tempat untuk mengatur bagaimana proyek Django berjalan.

d.	Merupakan proses sinkronisasi antara model Python yang kita definisikan di models.py dengan struktur tabel di database. Pertama, ketika kita membuat atau mengubah model, kita menjalankan python manage.py makemigrations. Perintah ini akan membuat file migrasi yang berisi instruksi perubahan (misalnya menambah tabel, menghapus kolom, atau mengubah field). Kedua, perintah python manage.py migrate digunakan untuk menerapkan perubahan tersebut ke database sehingga tabel dan kolom benar-benar dibuat atau dimodifikasi. Dengan cara ini, Django memastikan database selalu konsisten dengan model yang kita definisikan di kode.

e.	Django dipilih sebagai framework pertama untuk dipelajari karena memiliki konsep yang lengkap namun tetap mudah dipahami untuk pemula. Django menggunakan arsitektur Model-Template-View (MTV) yang jelas membagi logika aplikasi, data, dan tampilan. Selain itu, Django menyediakan banyak fitur bawaan seperti ORM, sistem autentikasi, admin panel, hingga keamanan web, sehingga mahasiswa dapat langsung fokus pada logika bisnis tanpa harus membangun semuanya dari nol. Django juga berbasis Python, bahasa pemrograman yang relatif mudah dipelajari. Oleh karena itu, Django sangat cocok untuk menjadi framework awal untuk dikenalkan kepada kita (mahasiswa).

Berikut adalah link aplikasi PWS: https://haikal-muzaki-sportsgear.pbp.cs.ui.ac.id/



# Tugas 3

1. Jelaskan mengapa kita memerlukan data delivery dalam pengimplementasian sebuah platform?
Kita memerlukan data delivery karena sebuah platform harus bisa bertukar informasi antara frontend dan backend, antar server, maupun dengan aplikasi lain. Data delivery memastikan informasi bisa dikirim dengan format yang konsisten sehingga sistem yang berbeda tetap bisa saling berkomunikasi. Selain itu, data delivery juga membuat data yang diterima dapat disimpan dengan baik dalam database sesuai struktur yang sudah ditentukan. Dengan begitu, platform bisa berjalan lancar dan setiap bagian tetap terhubung.

2. Menurutmu, mana yang lebih baik antara XML dan JSON? Mengapa JSON lebih populer dibandingkan XML?
XML dan JSON sama-sama bisa digunakan untuk mengirim data, tetapi JSON lebih baik untuk konteks web modern karena syntax-nya lebih sederhana, lebih ringkas, dan mudah dibaca. Struktur JSON mirip dengan unordered map atau objek di banyak bahasa pemrograman, sehingga developer sudah terbiasa menggunakannya. Selain itu, JSON langsung cocok dengan JavaScript, sehingga lebih cepat diproses di browser. Hal-hal inilah yang membuat JSON lebih populer dibandingkan XML.

3. Jelaskan fungsi dari method is_valid() pada form Django dan mengapa kita membutuhkan method tersebut?
Method is_valid() pada form Django berfungsi untuk mengecek apakah data yang dimasukkan user sudah sesuai aturan yang ditentukan. Method ini penting karena mencegah data yang tidak valid masuk ke database. Jadi, is_valid() berperan sebagai filter atau penjaga agar hanya data yang benar saja yang diproses oleh sistem.

4. Mengapa kita membutuhkan csrf_token saat membuat form di Django? Apa yang dapat terjadi jika kita tidak menambahkan csrf_token pada form Django? Bagaimana hal tersebut dapat dimanfaatkan oleh penyerang?
Kita membutuhkan csrf_token karena ini adalah cara Django melindungi aplikasi dari serangan CSRF (Cross-Site Request Forgery). Token ini memastikan bahwa setiap permintaan form benar-benar berasal dari halaman aplikasi kita, bukan dari situs lain. Jika csrf_token tidak digunakan, penyerang bisa memanfaatkan celah ini untuk mengirim permintaan palsu atas nama user yang sedang login, misalnya melakukan transfer uang atau mengubah data penting tanpa sepengetahuan user.

5. step-by-step actions:
1) sesuai dengan checklist pertama, kita membuat 4 fungsi baru yaitu show_json, show_xml, show_xml_by_id, dan show_json_by_id di views.py.
2) setelah membuat fungsi-fungsi tersebut, kita tidak lupa utnuk meng-import fungsi-fungsi tersebut di urls.py dan menambahkan path url ke dalam urlpatterns.
3) untuk checklist selanjutnya file yang harus diubah adalah main.html. Di tugas ini kita harus merubah main.html sehingga juga menampilkan tombol "add" dan "detail"
4) membuat forms.py yang sesuai dengan proyek kita. Nah di sini, saya juga sekalian melengkapi perubahan kode-kode yang diperlukan yang tadi belum disebut. Perubahan tersebut termasuk membuat base.html, menambahkan sesuatu di list templates dan CRF_TRUSTED_ORIGINS di settings.py, menambahkan beberapa import di views.py, meng-import fungsi-fungsi ke urls.py yang ada pada direktori main dan menambahkan path url ke dalam urlpatterns.
5) membuat show_product.html untuk menampilkan detail dari produk.
6) melengkapi kode dengan membuat create_product.html untuk menambahkan suatu produk.
7) Seharusnya proyek sudah sesuai dan dapat diluncurkan. Namun, dalam kasus saya, terdapat beberapa error yang terjadi karena terdapat nama fungsi/variabel/class yang tidak sesuai. Misalnya, saya memanggil product_detail padahal seharusnya saya memanggil show_product. Setelah masalah tersebut ditangani, saya akhirnya dapat menjalankan proyek saya.

6. Menurut saya tutorial yang diberikan sudah sangat lengkap dan dengan tutorial tersebut, mahasiswa dapat mempelajari dan mengerti materi yang ingin disampaikan. 

![foto show xml](./gambar_tugas3/Screenshot%20(119).png)
![foto show json](./gambar_tugas3/Screenshot%20(120).png)
![foto show json by id](./gambar_tugas3/Screenshot%20(121).png)
![foto show xml by id](./gambar_tugas3/Screenshot%20(122).png)

# Tugas 4

1. Apa itu Django AuthenticationForm? Jelaskan juga kelebihan dan kekurangannya.
Authentication form adalah form bawaan dari Django. Form ini dipakai untuk melakukan proses login. Secara default, form ini akan meminta username dan password. Ketika user men-submit form, Django akan langsung mengecek ke database apakah input tersebut valid atau tidak. Jika valid, user dapat login. Jika tidak valid, maka akan muncul pesan error. Secara esensial, AuthenticationForm ini digunakan untuk memverifikasi identitas user.
Kelebihan menggunakan AuthenticationForm adalah sebagai berikut:
- Bawaan Django. Karena ini, kita tidak perlu membuat form login lagi dengan manual.
- Keamanan cukup terjamin. AuthenticationForm memiliki fitur validasi password, hashing, dan perlindungan dari serangan umum.
- Dapat dikostumisasi. Kita dapat meng-override field (misalnya yang tadinya username menjadi email) dan juga styling form seperti dengan CSS.
- Error handling otomatis. Jika terdapat error seperti password yang salah, maka ia akan langsung mengeluarkan pesan error default.
Adapun kekurangan dari AuthenticationForm adalah seperti di bawah ini:
- Tampilan basic. Tampilan jika kita menggunakan AuthenticationForm dapat dibilang retro, untuk dapat dilihat lebih baik, kita perlu styling tampilan lebih lanjut.
- Kustomisasi pesan error terbatas. Kalau mau ubah pesan error jadi lebih user-friendly, perlu nulis ulang sebagian fungsi validasi.
- Tidak dapat digunakan/kurang cocok digunakan untuk sistem login yang kompleks. Contoh dari sistem login kompleks yang dimaksud adalah multi-factor authentication / OAuth login Google & Facebook.

2. Apa perbedaan antara autentikasi dan otorisasi? Bagaiamana Django mengimplementasikan kedua konsep tersebut? 
Autentikasi berfokus pada proses verifikasi identitas pengguna, yaitu memastikan bahwa seseorang benar-benar adalah dirinya dengan cara memasukkan kredensial seperti username dan password. Sedangkan otorisasi adalah tahap berikutnya setelah autentikasi berhasil. Otorisasi berhubungan dengan hak akses pengguna tersebut di dalam sistem. 
Untuk implementasinya di Django, autentikasi diimplementasikan melalui sistem bawaan yang disediakan oleh django.contrib.auth. Melalui fungsi seperti authenticate(), Django akan memvalidasi kombinasi username dan password yang dimasukkan oleh pengguna. Jika berhasil, fungsi login() akan menyimpan informasi pengguna tersebut dalam session sehingga ia dianggap sudah masuk ke sistem. Django juga menyediakan form bawaan seperti AuthenticationForm dan view LoginView untuk memudahkan proses login ini. Sementara itu, otorisasi diwujudkan melalui sistem permissions, groups, dan decorators. Permissions bisa berupa izin spesifik seperti can_add_product atau can_delete_product, sementara groups memungkinkan pengembang untuk mengelompokkan pengguna dalam role tertentu, misalnya admin, staff, atau user biasa. Django juga menyediakan berbagai cara untuk mengatur otorisasi di level view, seperti penggunaan @login_required untuk membatasi akses hanya bagi pengguna yang sudah login, atau @permission_required untuk memastikan hanya pengguna dengan izin tertentu yang bisa menjalankan suatu aksi, misalnya menghapus produk.

3. Apa saja kelebihan dan kekurangan session dan cookies dalam konteks menyimpan state di aplikasi web?
Pertama saya akan membahas kelebihan dan kekurangan session. Kelebihan session diantaranya yaitu:
- Lebih aman. Session lebih aman digunakan untuk informasi sensitif karena data akan disimpan di server.
- Dapat menyimpan data yang lebih besar dan kompleks.
- Risiko manipulasi data lebih rendah. Hal ini dikarenakan user hanya menyimpan session ID.
Adapun kekurangannya, yaitu:
- Beban terhadap server karena data harus disimpan dan diproses di server.
- Bersifat sementara. Biasanya hilang setelah browser ditutup atau server restart jika tidak ada mekanisme penyimpanan permanen.
- Membutuhkan lifecycle management.
Selanjutnya kita akan membahas cookies. Kita mulai dari kelebihannya, yaitu sebagai berikut:
- Disimpan di sisi klien (browser), jadinya tidak membebani server.
- Dapat bertahan lama dengan mengatur expired date, hal ini memungkinkan ia tetap bertahan walau setelah browser ditutup.
- Mudah digunakan untuk menyimpan preferensi pengguna atau data kecil.
Walau seperti itu, cookies juga memiliki kekurangannya sendiri, yaitu:
- Tidak dapat menyimpan data yang besar. Hal ini tentu dikarenakan kapasitasnya yang terbatas.
- Rentan diserang seperti melalui XSS attack.
- Tidak aman untuk menyimpan data sensitif karena tersimpan di klien.

4. Apakah penggunaan cookies aman secara default dalam pengembangan web, atau apakah ada risiko potensial yang harus diwaspadai? Bagaimana Django menangani hal tersebut?
Penggunaan cookies dalam pengembangan web tidak sepenuhnya aman, ada beberapa potential risk yang harus diwaspadai. Seperti yang disebutkan pada nomor sebelumnya, cookies disimpan di sisi klien, menyebabkan kerentanannya terhadap serangan tertentu lebih tinggi. Pada nomor sebelumnya, juga disebutkan salah satu bentuk serangannya yaitu XSS, hal tersebut dapat terjadi jika aplikasi tidak memfilter input dengan baik. Selain itu, terdapat juga risiko kerentanan terhadap session hijacking kalau session ID di dalam cookies berhasil dicegat. Tidak hanya itu, kita tidak dapat melupakan bahwa cookies dapat dimanipulasi langsung oleh pengguna, sehingga data sensitif tidak boleh kita simpan di dalamnya tanpa enkripsi atau perlindungan lain.
Namun, tentunya Django menyadari lubang-lubang security risk tersebut, sehingga Django sendiri memiliki beberapa mekanisme keamanan untuk mengurangi risiko-risiko tersebut. Mekanisme-mekanisme tersebut adalah sebagai berikut:
- Django secara default cookies session dengan flag HttpOnly, karena itu, cookies tidak dapat diakses melalui JavaScript, hal ini sangat membantu dalam mengurangi risiko serangan XSS.
- Terdapat opsi secure flag yang memastikan cookies hanya dikirim melalui koneksi HTTPS, sehingga dapat mengurangi kemungkinan terjadinya penyadapan jaringan tidak terenkripsi.
- Django menyediakan CSRF token yang disimpan dalam cookies dengan proteksi tambahan, hal ini khusus untuk mencegah terjadinya serangan CSRF.
- Terakhir, Django mendukung penggunaan SIGNED cookies, yaitu cookies yang sudah ditandatangani dengan secret key, sehingga meskipun pengguna mencoba memanipulasi isinya, Django akan mendeteksinya sebagai invalid.

5. Step by step action:
1) Pertama, kita membuat form registrasi user dengan mengimport form bawaan dari Django, menambahkan fungsi register dalam views.py, dan membuat template (html) dari form register tersebut. Jangan lupa untuk routing register di urls.py.
2) Hal berikutnya yang harus kita buat adalah login page. Prosesnya juga hampir sama dengan pembuatan register. Kita dapat mengimport langsung fungsi bawaan dari Django, menambahkan fungsi login dalam views.py, dan membuat template (html) login page tersebut. Jangan lupa untuk melakukan routing di urls.py.
3) Fungsi terakhir yang harus kita buat adalah logout. Prosesnya mirip seperti pembuatan dua fungsi sebelumnya. Pertama kita import logout (bukan mengimport fungsi bawaan Django), menambahkan fungsi logout di views.py, tambahkan button logout di main.html (mohon diperhatikan bahwa penambahn lines of code untuk menambahkan button logout dilakukan di main.html dan tidak membuat template khusus, hal ini karena kita sedang membuat fungsi dan button bukan membuat suatu halaman khusus), dan terakhir lakukan routing.
4) Lalu, kita perlu merestriksi akses halaman main dan show product supaya hanya bisa dibuka oleh user yang sudah login. Caranya dengan mengimport login_required, lalu menambahkan decorator @login_required(login_url='/login') di atas fungsi show_main dan show_product.
5) Selanjutnya, kita menggunakan data dari cookies. Pada fungsi login_user, kita modifikasi supaya menyimpan cookie baru bernama last_login dengan isi waktu terakhir user melakukan login. Jangan lupa tambahkan context last_login di show_main agar bisa ditampilkan di halaman main.
6) kita perlu menghapus cookie saat user logout. Caranya dengan memodifikasi fungsi logout_user supaya menambahkan response.delete_cookie('last_login'). Setelah itu, tambahkan line di main.html untuk menampilkan informasi waktu terakhir login user.
7) Selanjutnya, tambahkan field user pada model Product untuk menghubungkannya dengan model bawaan Django (User). Supaya perubahan ini berlaku, jalankan perintah makemigrations dan migrate.
8) Lalu, fungsi create_product dimodifikasi agar setiap berita yang dibuat otomatis tersimpan dengan identitas user yang sedang login. Hal ini dilakukan dengan commit=False pada form, kemudian field user diisi dengan request.user sebelum disimpan ke database.
9) Bagian show_main juga diperbarui sehingga daftar berita bisa difilter. Jika parameter filter bernilai all, maka semua artikel akan muncul. Namun, bila bernilai my, hanya artikel milik user yang sedang login yang ditampilkan. Selain itu, informasi username user login juga ikut ditampilkan di halaman.
10) Di sisi tampilan, tombol filter ditambahkan pada main.html agar pengguna bisa memilih untuk melihat seluruh artikel atau hanya artikel pribadinya.
11) Terakhir, bagian show_product.html diperluas dengan menampilkan nama pembuat artikel. Jika berita memiliki data user, maka username ditampilkan sebagai author, sementara jika tidak ada user, maka ditampilkan sebagai Anonymous.
more focused answer regarding the checklist:
- Mengimplementasikan fungsi registrasi, login, dan logout. Langkah awal yang saya lakukan adalah membuat form registrasi menggunakan UserCreationForm bawaan dari Django. Saya menambahkan fungsi register pada views.py, membuat template register.html, serta menambahkan routing pada urls.py. Setelah registrasi selesai, saya melanjutkan dengan membuat login page menggunakan AuthenticationForm. Prosesnya mirip, yaitu menambahkan fungsi login_user pada views.py, membuat template login.html, serta menambahkan routing di urls.py. Untuk fungsi logout, saya mengimpor logout, membuat fungsi logout_user pada views.py, serta menambahkan tombol logout di main.html tanpa membuat template baru, karena logout hanya berupa aksi, bukan halaman khusus.

- Membuat dua akun pengguna dengan dummy data. Setelah fungsi login dan registrasi berjalan dengan baik, saya membuat dua akun pengguna yang berbeda melalui halaman register. Masing-masing akun saya gunakan untuk membuat tiga data dummy pada model yang telah tersedia sebelumnya. Hal ini bertujuan untuk menguji apakah data benar-benar terasosiasi dengan akun pembuatnya serta dapat dibedakan saat pengguna yang berbeda login. Username yang saya gunakan adalah haikal dan muza, masing-masing saya uji dengan tiga contoh produk dengan karakteristik yang berbeda guna menguji model yang telah dibuat. Hal-hal yang dites dengan perbedaaan karakteristik yaitu harga (berpengaruh pada tag premium), jenis produk (ball, jersey, dll), featured, dan lainnya.

- Menghubungkan model Product dengan User. Untuk menghubungkan data dengan pengguna, saya menambahkan field user = models.ForeignKey(User, on_delete=models.CASCADE, null=True) pada model Product. Langkah ini memastikan bahwa setiap data yang dibuat dapat terhubung langsung dengan akun penggunanya. Setelah itu, saya menjalankan perintah makemigrations dan migrate agar perubahan tersebut tercatat dalam basis data.

- Menampilkan detail informasi pengguna dan cookies. Pada tahap ini, saya memodifikasi fungsi login_user agar menyimpan cookies baru bernama last_login, yang berisi informasi waktu terakhir pengguna berhasil login. Kemudian, saya menambahkan last_login ke dalam context di show_main, sehingga informasi tersebut dapat ditampilkan pada halaman utama. Selain itu, saya juga memodifikasi fungsi logout_user untuk menghapus cookies tersebut dengan response.delete_cookie('last_login'). Dengan demikian, setiap kali pengguna login atau logout, informasi sesi terakhir dapat dikelola dengan baik.

# Tugas 5

1. singkatnya, CSS memilih aturan berdasarkan importance & origin terlebih dahulu, lalu specificity, dan terakhir source order. Kalau dua aturan sama-sama berlaku, yang lebih penting/lebih spesifik/ditulis belakangan yang menang. Untuk lebih jelasnya, CSS pertama melihat mana aturan yang dianggap paling penting. Di sinilah !important muncul. Kalau ada deklarasi dengan tanda itu, biasanya langsung didahulukan dibanding aturan lain. Tapi sebenarnya ada urutan sumber juga, aturan bawaan browser, aturan yang ditulis pengguna, dan aturan yang ditulis penulis website, dan masing-masing punya bobot berbeda. Setelah lapisan “penting atau tidak” ini dibereskan, barulah CSS menimbang spesifisitas. Aturan yang lebih spesifik ke elemen tertentu akan menang dari aturan yang sifatnya lebih umum. Misalnya selektor yang menunjuk ID dianggap jauh lebih kuat daripada yang hanya menunjuk class, dan class sendiri lebih kuat dibanding sekadar menyebut nama elemen. Kalau aturan datang dari atribut style langsung di dalam elemen, itu malah lebih berat lagi karena dianggap benar-benar ditulis khusus untuk elemen tersebut. Kalau ternyata tingkat kepentingan dan spesifisitas sama, CSS masih punya satu cara lagi yaitu posisi aturan dalam urutan pembacaan. Aturan yang muncul lebih akhir dalam stylesheet akan mengalahkan aturan sebelumnya. Jadi bisa dibilang prinsipnya adalah lihat dulu yang paling penting, kalau masih imbang cek siapa yang lebih spesifik, dan kalau masih sama juga, siapa yang ditulis belakangan itulah yang dipakai.

2. Responsive design sangat diperlukan karena pola penggunaan web saat ini sudah sangat beragam. Orang tidak hanya mengakses situs lewat komputer, tapi juga lewat ponsel atau device lain yang memiliki layar yang kecil. Kalau tampilan sebuah aplikasi web tidak menyesuaikan diri dengan lebar dan karakteristik layar pengguna, pengalaman user juga pasti akan terganggu. Dengan responsive design, satu basis kode dapat digunakan untuk semua jenis perangkat tanpa perlu membuat versi terpisah, dan hal ini langsung berpengaruh pada kepuasan pengguna yang berarti juga berdampak pada nama baik serta reputasi brand. Setelah kita tau kepentingannya, alangkah baiknya kita juga mengetahui contoh aplikasinya. Contoh aplikasi yang responsif adalah Tokopedia. Situs maupun aplikasinya diakses jutaan orang Indonesia, dan desainnya responsif. Ketika dibuka di desktop, tampilannya luas dengan banyak elemen produk sekaligus, tapi begitu dibuka lewat ponsel, layout menyesuaikan, tombol lebih besar, dan navigasi disederhanakan sehingga nyaman disentuh. Inilah praktik responsive design yang berhasil, karena konsisten enak dipakai di perangkat apapun. Sebaliknya, ada juga aplikasi atau situs yang masih ketinggalan. Misalnya beberapa situs pemerintah di Indonesia yang hanya mendesain tampilan untuk desktop. Begitu diakses lewat smartphone, teks mengecil, menu tersembunyi, bahkan kadang harus melakukan zoom manual agar terbaca. Ini jelas menyulitkan, padahal mayoritas masyarakat Indonesia mengakses internet justru dari ponsel. Ketiadaan responsive design membuat layanan yang seharusnya publik-friendly jadi tidak ramah pengguna.

3. Margin, border, dan padding adalah tiga lapisan ruang yang mengatur jarak dan batas suatu elemen, dan masing-masing memiliki fungsi yang berbeda. Margin bisa dianggap sebagai ruang kosong di luar elemen. Margin mengatur jarak antara elemen dengan elemen lain di sekitarnya. Border berada tepat di tepi elemen, mengelilingi kontennya, dan biasanya terlihat karena dapat diberi warna, ketebalan, bahkan gaya garis. Border berfungsi sebagai batas visual yang jelas, dapat dikatakan seperti bingkai yang memisahkan isi elemen dengan bagian luar. Sementara itu, padding adalah ruang kosong di dalam elemen, tepat di antara isi konten dan border. Padding memberi jarak agar teks atau gambar tidak terlalu mepet dengan tepi kotak, sehingga tampilannya lebih nyaman dilihat. Untuk mengimplementasikannya, kita bisa menggunakan properti CSS yang sesuai. Misalnya, jika ingin memberi jarak antar elemen, kita bisa menulis margin: 20px;. Jika ingin memberi bingkai, kita menambahkan border: 2px solid black;. Sedangkan jika ingin memberi ruang antara teks dengan garis bingkai, kita gunakan padding: 10px;.

4. Flexbox atau Flexible Box Layout adalah model tata letak satu dimensi pada CSS yang digunakan untuk mengatur distribusi ruang dan perataan elemen di sepanjang baris atau kolom. Konsep utama flexbox adalah penggunaan sumbu utama dan sumbu silang sehingga elemen dapat diatur posisinya secara fleksibel. Flexbox bermanfaat untuk membuat navigasi, menyusun tombol, menyejajarkan elemen secara vertikal maupun horizontal, serta menyesuaikan ukuran elemen dengan ruang yang tersedia. Model ini lebih tepat digunakan ketika kebutuhan tata letak berfokus pada satu dimensi. Grid Layout adalah model tata letak dua dimensi yang memungkinkan pengaturan baris dan kolom secara bersamaan. Grid memudahkan pembuatan struktur halaman yang kompleks seperti dashboard, galeri, atau pembagian area halaman karena dapat mengatur posisi elemen dengan jelas dan teratur. Grid lebih sesuai dipakai ketika desain membutuhkan kontrol penuh terhadap baris dan kolom sekaligus. Dalam praktiknya flexbox dan grid sering dipakai bersama. Grid digunakan untuk membentuk kerangka utama halaman sedangkan flexbox digunakan untuk mengatur detail isi di dalam setiap bagian. Pemilihan keduanya bergantung pada apakah tata letak lebih menekankan satu dimensi atau dua dimensi serta kebutuhan responsivitas desain.

5. Untuk mengimplementasikan checklist di atas secara step-by-step, hal pertama yang dilakukan adalah menyiapkan fitur edit dan hapus produk. Untuk fitur edit, perlu dibuat view yang menampilkan form berisi data produk yang sudah tersimpan. Form tersebut kemudian dapat diperbarui sesuai input baru dari pengguna. Setelah pengguna menyimpan perubahan, data produk di-update di basis data, lalu diarahkan kembali ke halaman daftar produk. Untuk fitur hapus, dibuat view yang menerima parameter berupa identitas produk tertentu. Produk dengan identitas tersebut kemudian dihapus dari basis data, dan pengguna dikembalikan ke halaman daftar produk setelah penghapusan selesai. Implementasi keduanya juga membutuhkan penyesuaian pada urls.py, agar path untuk mengedit maupun menghapus produk dapat diakses melalui URL.

Setelah fungsi edit dan hapus produk selesai diimplementasikan, tahap selanjutnya adalah melakukan kustomisasi pada desain antarmuka agar aplikasi lebih menarik dan nyaman digunakan. Kustomisasi ini mencakup hampir seluruh halaman, mulai dari login, register, tambah produk, edit produk, hingga detail produk. Dengan memanfaatkan utilitas dari Tailwind, setiap halaman dapat dibuat lebih konsisten dari segi tipografi, warna, serta tata letak. Misalnya, form login dan register dapat dikemas ke dalam sebuah card sederhana dengan border yang lembut, padding yang cukup, serta tombol aksi yang lebih menonjol. Hal serupa juga berlaku untuk form tambah dan edit produk, di mana setiap input dapat dipertegas dengan label yang rapi dan tombol submit yang jelas, sehingga pengalaman pengguna terasa lebih profesional.

Halaman detail produk pun perlu diperhatikan, sebab di sinilah informasi mengenai satu produk ditampilkan lebih lengkap. Tampilan dapat difokuskan pada penggunaan card berisi gambar, deskripsi, dan informasi harga, sehingga pengguna bisa langsung memahami produk tanpa distraksi. Perubahan desain yang konsisten di seluruh halaman ini akan menciptakan kesan aplikasi yang matang dan terstruktur dengan baik.

Selain itu, halaman daftar produk merupakan bagian penting yang harus responsif dan menarik. Apabila belum ada produk yang tersimpan, halaman tidak boleh dibiarkan kosong, melainkan tetap menampilkan ilustrasi beserta pesan informatif bahwa belum ada produk terdaftar. Sebaliknya, jika sudah ada produk yang tersimpan, maka produk tersebut perlu ditampilkan menggunakan card. Card ini tidak boleh menyalin persis desain dari tutorial, sehingga perlu dikreasikan ulang, misalnya dengan pengaturan grid yang rapi, efek hover, atau bayangan halus untuk memberikan kesan modern. Pada setiap card juga harus tersedia tombol edit dan hapus agar pengguna dapat langsung mengelola produk dari daftar tanpa harus membuka halaman lain terlebih dahulu.

Card yang diimplementasikan menampilkan thumbnail produk, atau placeholder bila gambar tidak tersedia, kemudian dilengkapi dengan badge kategori serta badge status untuk menandai produk sebagai featured atau premium. Saat kursor diarahkan ke card, muncul overlay berisi harga singkat serta tombol quick view yang memudahkan pengguna melihat detail produk dengan cepat. Bagian metadata menampilkan tanggal pembuatan produk dan harga dalam format yang lebih jelas, sedangkan judul produk ditampilkan sebagai tautan yang dapat diklik menuju halaman detail. Deskripsi produk dipangkas agar ringkas dan tidak merusak tata letak, serta aksi Edit dan Delete ditampilkan secara kondisional hanya bagi pemilik produk yang sedang login. Dengan kombinasi elemen-elemen ini, card tidak hanya berfungsi sebagai wadah informasi produk, tetapi juga mempermudah pengelolaan produk langsung dari daftar.

Terakhir, agar navigasi antarhalaman menjadi lebih mudah, aplikasi memerlukan sebuah navigation bar yang responsif. Dengan Tailwind, navbar dapat dibuat sederhana namun fleksibel, menampilkan daftar menu secara horizontal di perangkat berlayar lebar, dan otomatis bertransformasi menjadi menu tersembunyi dengan tombol hamburger pada perangkat berlayar kecil. Hal ini memastikan bahwa pengguna tetap bisa mengakses fitur-fitur utama seperti daftar produk, tambah produk, login, atau logout dengan nyaman, baik di desktop maupun mobile.